snippet dotmod! dotfiles Lua module
	--- ${1:TODO: Documentation}
	local M = require('dotfiles.autoload')('`dotfiles#ft#lua#module_name()`', {})

	${2:local lsp = require('vim.lsp')}

	$0

	return M
snippet lspconf! vim.lsp config module
	---@type dotfiles.lsp.Config
	return {
		$0
	}
snippet schedule call to vim.schedule()
	vim.schedule(function()
		$0
	end)
snippet schedulewrap call to vim.schedule_wrap()
	vim.schedule_wrap(function()
		$0
	end)
snippet optrequire optional require()
	local has_${2:module}, ${2:module} = pcall(require, '$1')
snippet iterlist iterate over a list-style table
	for ${3:_}, ${2:element} in ipairs(${1:list}) do
		$0
	end
snippet iterdict iterate over a dictionary-style table
	for ${2:key}, ${3:value} in ipairs(${1:dict}) do
		$0
	end
snippet nodecallback Node.js-style callback for luv
	function(${2:err}, ${1:...})
		if ${2:err} then
			return callback(${2:err})
		end
		$0
	end
snippet timeit measure time of a section of code
	local start_time${1:_test} = vim.uv.hrtime()
	$0
	local elapsed_time${1:_test} = vim.uv.hrtime() - start_time${1:_test}
	print(elapsed_time${1:_test} / 1e6)
snippet validate check a parameter with vim.validate()
	vim.validate('${1}', ${1:param}, '${2:type}')
snippet diagnext disable a diagnostic on the next line
	---@diagnostic disable-next-line: $0
snippet diagline disable a diagnostic on the current line
	---@diagnostic disable-line: $0
snippet patchfn monkey-patch a function
	$1._old_$2 = $1._old_$2 or $1.$2
	function ${1:table}.${2:method}(${3:...})
		return $1._old_$2($3)$0
	end
snippet patchcls monkey-patch a class method
	$1._old_$2 = $1._old_$2 or $1.$2
	function ${1:table}:${2:method}(${3:...})
		return self:_old_$2($3)$0
	end
snippet patchval monkey-patch a value
	local old_${1:field} = ${2:table}.$1
	$2.$1 = ${3:...}
	$0
	$2.$1 = old_$1
snippet format string.format()
	('$1'):format($0)
snippet @as type cast comment
	--[[@as $0]]
snippet @type type annotation comment
	---@type $0
