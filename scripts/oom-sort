#!/usr/bin/env bash
# This script is a rewrite of <https://github.com/hakavlad/nohang/blob/72ced0a0c4cc0c5fc1c8fa8778e9499e80c6ada9/src/oom-sort>

set -euo pipefail
# Don't update $LINES and $COLUMNS automatically, though they can still be used
# if provided via environment variables.
shopt -u checkwinsize

join() {
  local IFS="$1"
  shift
  printf '%s' "$*"
}

# Source: <https://www.reddit.com/r/bash/comments/8nau9m/comment/dzuj7a0/>
trim() {
  local out="$1" str="$2"
  str=${str#"${str%%[![:space:]]*}"}
  str=${str%"${str##*[![:space:]]}"}
  eval "${out}=\"\$str\""
}

columns=( score adj UID PID Name RSS Swap cmdline )

declare -A columns_lookup
for i in "${!columns[@]}"; do
  columns_lookup["${columns[$i]}"]=$((i+1))
done

sort_by="${1-score}"

if [[ -z "$sort_by" || -z "${columns_lookup[$sort_by]+1}" ]]; then
  echo >&2 "usage: $0 <$(join '|' "${columns[@]}")>"
  exit 1
fi

my_pid="$$"

for proc in /proc/*; do
  col_PID="${proc##*/}"
  if [[ -d "$proc" && "$col_PID" != *[![:digit:]]* ]]; then
    # Don't include the init process and this shell script in the output table.
    (( col_PID == 1 || col_PID == my_pid )) && continue

    readarray -t -d '' cmdline < "$proc/cmdline"

    # Probably a kernel thread if the command line is empty
    # <https://stackoverflow.com/questions/12213445/identifying-kernel-threads>
    (( ${#cmdline[@]} == 0 )) && continue

    # Replace unprintable characters (notably newlines and tabs, which would
    # break the formatting of the table) with U+FFFD ï¿½  REPLACEMENT CHARACTER.
    col_cmdline="${cmdline[*]//[![:print:]]/$'\ufffd'}"

    while IFS=$'\t' read -r -a items; do
      case "${items[0]-}" in
        (Name:) col_Name=${items[1]:0:15} ;;
        (Uid:) col_UID=${items[2]} ;;
        (VmRSS:) col_RSS=$(( ${items[1]% kB} * 1024 )) ;;
        (VmSwap:) col_Swap=$(( ${items[1]% kB} * 1024 )) ;;
        # Also leave out this script's subprocesses from the output.
        (PPid:) (( ${items[1]} == my_pid )) && continue 2;;
      esac
    done < "$proc/status"

    read -r col_score < "$proc/oom_score" || true
    read -r col_adj < "$proc/oom_score_adj" || true

    for var in "${columns[@]}"; do
      var="col_${var}"
      printf '%s\t' "${!var-}"
    done

    printf '\n'
  fi
done |

  sort --field-separator=$'\t' --numeric-sort --reverse --key="${columns_lookup[$sort_by]}" |
  numfmt --delimiter=$'\t' --to=iec --field="${columns_lookup[RSS]},${columns_lookup[Swap]}" |
  column --table --separator=$'\t' \
    --table-columns="$(join ',' "${columns[@]}")" \
    --table-columns-limit="${#columns[@]}" \
    ${COLUMNS:+"--table-truncate=${columns_lookup[cmdline]}"} \
    ${COLUMNS:+"--output-width=${COLUMNS}"} |

  if [[ -t 1 ]]; then
    PAGER="${PAGER:-less}"
    if [[ "$PAGER" == *less* ]]; then
      PAGER+=' -S'  # --chop-long-lines
      if [[ "$(${PAGER} --help)" == *" --header="* ]]; then
        PAGER+=' --header=1'
      fi
    fi
    ${PAGER}
  else
    cat -
  fi
