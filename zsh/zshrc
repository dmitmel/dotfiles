#!/usr/bin/env zsh

# Performance {{{

  zmodload zsh/datetime  # to read `$EPOCHREALTIME`
  typeset -gA _perf_timers

  _perf_timer_start() {
    local name="$1"
    if [[ -z "$name" ]]; then
      print >&2 "$0: usage: $0 <name>"
      return 1
    fi
    _perf_timers[$name]="$EPOCHREALTIME"
  }

  _perf_timer_stop() {
    # Record the stop time as precisely as possible even in the case of an error
    local stop_time="$EPOCHREALTIME"
    local name="$1"
    if [[ -z "$name" ]]; then
      print >&2 "$0: usage: $0 <name>"
      return 1
    fi
    local start_time="${_perf_timers[$name]}"
    unset "_perf_timers[$name]"
    local -i duration="$(( (stop_time - start_time) * 1000 ))"
    print -r -- "$(print -P '%F{8}==>%f') ${name}: ${duration}ms"
  }

# }}}

_perf_timer_start "total"

ZSH_DOTFILES="${0:A:h}"

ZSH_CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles"
mkdir -pv -- "$ZSH_CACHE_DIR"

# Zsh can define a function under multiple different names, apparently
function _source _zplg_load {
  _perf_timer_start "${1:t}"
  builtin source "$@"
  _perf_timer_stop "${1:t}"
}

if (( ${+functions[compdef]} )); then
  print >&2 -P '%F{red}`compinit` must not be called before loading the dotfiles!%f'
else
  # This idea was borrowed from zinit: to simplify the loading sequence, if any
  # scripts or plugins call `compdef` before the completion system is properly
  # initialized, then record those calls in an array to replay them later.
  typeset -ga _deferred_compdefs
  compdef() {
    _deferred_compdefs+=("$0 ${(j: :)${(q)@}}")
  }
fi

autoload -Uz colors && colors

for script in functions options path env zplg plugins aliases completion zle alias_tips prompt colorscheme; do
  _source "$ZSH_DOTFILES/$script.zsh"
done; unset script

if is_function _dotfiles_customizations; then
  _dotfiles_customizations
fi

_perf_timer_stop "total"

if [[ -z "$DOTFILES_DISABLE_WELCOME" && -z "$POETRY_ACTIVE" ]]; then
  welcome
fi

if [[ -z "$DOTFILES_DONT_SYNC_DIRSTACK" && "${#dirstack}" -eq 0 ]]; then
  dirstack_load
fi

if [[ -n "$DOTFILES_RUN_HTOP_AFTER_START" ]]; then
  # Make it look as if the command was typed in interactively
  print -Pn -- "$PROMPT"
  print "htop"
  if is_function omz_termsupport_preexec; then
    omz_termsupport_preexec htop htop htop
  fi
  htop
fi
