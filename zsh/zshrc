#!/usr/bin/env zsh

# Performance {{{

  zmodload zsh/datetime  # to read `$EPOCHREALTIME`
  typeset -gA _perf_timers

  _perf_timer_start() {
    local name="$1"
    if [[ -z "$name" ]]; then
      print >&2 "$0: usage: $0 <name>"
      return 1
    fi
    _perf_timers[$name]="$EPOCHREALTIME"
  }

  _perf_timer_stop() {
    # Record the stop time as precisely as possible even in case of an error
    local stop_time="$EPOCHREALTIME"
    local name="$1"
    if [[ -z "$name" ]]; then
      print >&2 "$0: usage: $0 <name>"
      return 1
    fi
    local start_time="${_perf_timers[$name]}"
    unset "_perf_timers[$name]"
    local -i duration="$(( (stop_time - start_time) * 1000 ))"
    print -r -- "$(print -P '%F{8}==>%f') ${name}: ${duration}ms"
  }

# }}}

_perf_timer_start "total"

ZSH_DOTFILES="${0:A:h}"

ZSH_CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles"
mkdir -pv -- "$ZSH_CACHE_DIR"

# Zsh can define a function under multiple different names, apparently
function _source _zplg_load {
  _perf_timer_start "${1:t}"
  builtin source "$@"
  _perf_timer_stop "${1:t}"
}

if (( ${+functions[compdef]} )); then
  print >&2 -P '%F{red}`compinit` must not be called before loading the dotfiles!%f'
else
  # This idea was borrowed from zinit: to simplify the loading sequence, if any
  # scripts or plugins call `compdef` before the completion system is properly
  # initialized, then record those calls in an array to replay them later.
  typeset -ga _deferred_compdefs
  compdef() {
    _deferred_compdefs+=("$0 ${(j: :)${(q)@}}")
  }
fi

autoload -Uz colors && colors

for script in functions options path env; do
  _source "${ZSH_DOTFILES}/${script}.zsh"
done; unset script

integer welcome_fd=-1
{

  if [[ -z "$DOTFILES_DISABLE_WELCOME" && -z "$POETRY_ACTIVE" ]]; then
    # Once the basic shell environment has been configured, start the `welcome`
    # script in the background and open a pipe to read its output. The script
    # will collect information about the system in parallel with the heavier
    # part of the Zsh startup procedure, and once that's done we can read its
    # output from this pipe to display it to the user.
    exec {welcome_fd}< <(welcome)
  fi

  for script in zplg plugins aliases completion zle alias_tips prompt colorscheme; do
    _source "${ZSH_DOTFILES}/${script}.zsh"
  done; unset script

  if is_function _dotfiles_customizations; then
    _dotfiles_customizations
  fi

  if [[ -z "$DOTFILES_DONT_SYNC_DIRSTACK" && "${#dirstack}" -eq 0 ]]; then
    dirstack_load
  fi

  _perf_timer_stop "total"

  if (( welcome_fd >= 0 )); then
    # A pure-Zsh version of `cat`. `-u` specifies the file descriptor to read
    # from, `-r` disables special processing of backslashes, `-e` tells `read`
    # to print the read text to stdout, without saving it in a variable. See:
    # <https://github.com/zsh-users/zsh/blob/zsh-5.9/Functions/Example/cat>
    while IFS= read -u "$welcome_fd" -r -e; do; done
  fi

} always {
  if (( welcome_fd >= 0 )); then
    exec {welcome_fd}<&-  # close our pipe with this ugly-ass syntax
  fi
}

if [[ -n "$DOTFILES_RUN_HTOP_AFTER_START" ]]; then
  # Make it look as if the command was typed in interactively
  print -Pn -- "$PROMPT"
  print "htop"
  if is_function omz_termsupport_preexec; then
    omz_termsupport_preexec htop htop htop
  fi
  htop
fi
