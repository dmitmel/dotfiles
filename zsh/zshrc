# Performance {{{

  zmodload zsh/datetime  # to read `$EPOCHREALTIME`
  typeset -gA _perf_timers

  _perf_timer_start() {
    local name="${1:?timer name is needed}"
    _perf_timers[$name]="$EPOCHREALTIME"
  }

  _perf_timer_stop() {
    # Record the stop time as precisely as possible even in case of an error
    local stop_time="$EPOCHREALTIME"
    local name="${1:?timer name is needed}"
    local start_time="${_perf_timers[$name]}"
    unset "_perf_timers[$name]"

    integer duration
    (( duration = (stop_time - start_time) * 1000 ))

    if [[ -z "$DOTFILES_ZSHRC_SILENT" ]]; then
      local arrow='%F{8}==>%f'
      print >&2 -r -- "${(%)arrow} ${name}: ${duration}ms"
    fi
  }

# }}}

_perf_timer_start "total"

# How this weird abomination for getting the path to the current script works:
# <https://unix.stackexchange.com/questions/386113/zsh-expansion-syntax>
# <https://github.com/zdharma-continuum/Zsh-100-Commits-Club/blob/master/Zsh-Plugin-Standard.adoc#1-standardized-0-handling>
ZSH_DOTFILES="${${(%):-%N}:A:h}"

ZSH_CACHE_DIR="${XDG_CACHE_HOME:-${HOME}/.cache}/dotfiles"
if [[ ! -d "$ZSH_CACHE_DIR" ]]; then
  command mkdir -pv -- "$ZSH_CACHE_DIR"
fi

# Zsh can define a function under multiple different names, apparently
function perf_source _zplg_load {
  {
    _perf_timer_start "${1:t}"
    builtin source "$@"
  } always {
    _perf_timer_stop "${1:t}"
  }
}

if (( ${+functions[compdef]} )); then
  print >&2 -P '%F{red}`compinit` must not be called before loading the dotfiles!%f'
else
  # This idea was borrowed from zinit: to simplify the loading sequence, if any
  # scripts or plugins call `compdef` before the completion system is properly
  # initialized, then record those calls in an array to replay them later.
  typeset -ga _deferred_compdefs
  compdef() {
    _deferred_compdefs+=("$0 ${(j: :)${(q)@}}")
  }
fi

autoload -Uz colors && colors

for script in options functions path; do
  perf_source "${ZSH_DOTFILES}/${script}.zsh"
done; unset script

integer welcome_fd=-1
{

  if [[ -z "$DOTFILES_ZSHRC_SILENT" && -z "$DOTFILES_DISABLE_WELCOME" && -z "$POETRY_ACTIVE" ]]; then
    # Once the basic shell environment has been configured, start the `welcome`
    # script in the background and open a pipe to read its output. The script
    # will collect information about the system in parallel with the heavier
    # part of the Zsh startup procedure, and once that's done we can read its
    # output from this pipe to display it to the user.
    exec {welcome_fd}< <(welcome)
  fi

  for script in env prompt zplg plugins aliases completion zle alias_tips colorscheme; do
    perf_source "${ZSH_DOTFILES}/${script}.zsh"
  done; unset script

  if is_function _dotfiles_customizations; then
    _dotfiles_customizations
  fi

  _perf_timer_stop "total"

  if (( welcome_fd >= 0 )); then
    # A pure-Zsh version of `cat`. The flag `-u` of `read` and `print` specifies
    # the file descriptor to read from or write to.
    while IFS= read -r -u "$welcome_fd"; do print -r -u2 -- "$REPLY"; done
  fi

} always {
  if (( welcome_fd >= 0 )); then
    exec {welcome_fd}<&-  # close our pipe with this ugly-ass syntax
  fi
  unset welcome_fd
}

if [[ -n "$KITTY_INSTALLATION_DIR" && -n "$KITTY_SHELL_INTEGRATION" ]]; then
  autoload -Uz -- "${KITTY_INSTALLATION_DIR}/shell-integration/zsh/kitty-integration"
  kitty-integration
  unfunction kitty-integration
fi

if is_function _ksi_deferred_init && [[ -n "$KITTY_SI_RUN_COMMAND_AT_STARTUP" ]]; then
  # Render the prompt to make it look as if the command was typed in interactively
  print -Pn -- "$PROMPT"
  # The (V) modifier escapes non-printable characters in the string to make them visible
  print -r -- "${(V)KITTY_SI_RUN_COMMAND_AT_STARTUP}"
fi
